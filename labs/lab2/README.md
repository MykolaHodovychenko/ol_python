# Практическая работа 2. Работа с циклами и списками. Механизм срезов

### Работа с циклами

**Задание 1**

Дан список целых чисел. Функция возвращает количество четных чисел в списке.

Пример:

```
countEvens([2, 1, 2, 3, 4]) → 3
countEvens([2, 2, 0]) → 3
countEvens([1, 3, 5]) → 0
```

**Задание 2**

Функция принимает целое число и возвращает первую цифру числа. Используйте цикл `while`, для получения абсолютного значения числа используйте функцию `abs()`. Не используйте преобразование числа в строку.

Пример:

```
first_digit(3572) → 3
first_digit(-947) → 9
first_digit(6) → 6
```

**Задание 3**

Функция принимает на вход список и возвращает измененный список, в котором элементы должны быть расположены так, что все четные числа идут первыми, а затем идут все нечетные числа. Порядок чисел может быть любым.

*Попробуйте решить задачу без использования вспомогательных списков, переставляя элементы внутри входного списка*

Пример:

```
even_odd([1, 0, 1, 0, 0, 1, 1]) → [0, 0, 0, 1, 1, 1, 1]
even_odd([3, 3, 2]) → [2, 3, 3]
even_odd([2, 2, 2]) → [2, 2, 2]
```

### Работа со списками


**Задание 1**

Реализуйте метод, который принимает на вход список целых чисел и возвращает измененный список **той же длины**, в котором убраны все вхождения числа 10. Элементы в списке сдвигаются влево, а оставшееся место до длины исходного списка заполняется числом 0. Например, список `{1, 10, 10, 2}` должен быть преобразован в список `{1, 2, 0, 0}`. Вы можете вернуть тот же самый список или создать новый.

Например:

```
task([1, 10, 10, 2]) -> [1, 2, 0, 0]
task([10, 2, 10]) -> [2, 0, 0]
task([1, 99, 10]) -> [1, 99, 0]
```

**Задание 2**

Реализуйте метод, который принимает на вход список целых чисел и возвращает `True`, если список содержит три четных или три нечетных числа подряд.

Например:

```
task([2, 1, 3, 5]) -> True
task([2, 1, 2, 5]) -> False
task([2, 4, 2, 5]) -> True
```

**Задание 3**

Реализуйте метод, который принимает на вход список целых чисел и возвращает `True`, если в списке встречается число 3 ровно три раза и нет двух подряд чисел 3.

Например:

```
task([3, 1, 3, 1, 3]) -> True
task([3, 1, 3, 3]) -> False
task([3, 4, 3, 3, 4]) -> False
```

### Механизм срезов 

**Задание 1**

Реализуйте функцию, которая принимает на вход строку и возвращает первую половину строки. К примеру,
строка `'WooHoo'` превратится в `'Woo'`.

Например:

```
task('WooHoo') → 'Woo'
task('HelloThere') → 'Hello'
task('abcdef') → 'abc'
```

**Задание 2**

Реализуйте функцию, которая принимает на вход две строки и возвращает новую строку, которая является
конкатенацией двух исходных строк без первых символов этих строк. Длина входящих строк больше 1 символа.

Например:

```
task('Hello', 'There') → 'ellohere'
task('java', 'code') → 'avaode'
task('shotl', 'java') → 'hotlava'
```

**Задание 3**

Реализуйте функцию, которая принимает на вход строку и возвращает новую строку, в которой три раза повторены
два последних символа исходной строки. Будем считать, что длина входной строки 2 и более символа.

*ДЛЯ РЕАЛИЗАЦИИ ЭТОЙ ЗАДАЧИ ИСПОЛЬЗУЙТЕ МЕХАНИЗМ СРЕЗОВ*

Например:

```
task('Hello') → 'lololo'
task('ab') → 'ababab'
task('Hi') → 'HiHiHi'
```

**Задание 4**

Реализуйте функцию, которая принимает на вход строку и возвращает строку,
которая состоит из двух символов, которые стоят в середине исходной строки.
Длина исходной строки будет более 2 символов

Например:

```
task("string") → "ri"
task("code") → "od"
task("Practice") → "ct"
```

